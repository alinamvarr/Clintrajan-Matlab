function [tree_extended] = compute_tree_from_python(X, varargin)
    % Parse optional parameters
    p = inputParser;
    addRequired(p, 'X');
    addParameter(p, 'nnodes', 50, @isnumeric);
    addParameter(p, 'alpha', 0.01, @isnumeric);
    addParameter(p, 'Mu', 0.1, @isnumeric);
    addParameter(p, 'Lambda', 0.05, @isnumeric);
    addParameter(p, 'FinalEnergy', 'Penalized', @ischar);
    addParameter(p, 'Do_PCA', true, @islogical);
    parse(p, X, varargin{:});
    
    % Convert MATLAB logical to Python string
    if p.Results.Do_PCA
        do_pca_str = 'True';
    else
        do_pca_str = 'False';
    end

    % Create Python script
    python_script = sprintf([...
        'import numpy as np\n',...
        'import elpigraph\n',...
        'import networkx as nx\n',...
        'import igraph\n',...
        'from scipy.io import savemat, loadmat\n',...
        'from elpigraph.src.core import PartitionData\n',...
        'from elpigraph.src.reporting import project_point_onto_graph, project_point_onto_edge\n',...
        'import copy\n\n',...
        'def compute_tree(input_file, output_file):\n',...
        '    # Load data\n',...
        '    data = loadmat(input_file)\n',...
        '    X = data["X"]\n',...
        '    \n',...
        '    # Print shape for debugging\n',...
        '    print(f"Input data shape: {X.shape}")\n',...
        '    \n',...
        '    # Compute elastic tree\n',...
        '    tree_elpi = elpigraph.computeElasticPrincipalTree(X, %d,\n',...
        '                                                    alpha=%.3f,\n',...
        '                                                    Mu=%.3f,\n',...
        '                                                    Lambda=%.3f,\n',...
        '                                                    FinalEnergy="%s",\n',...
        '                                                    Do_PCA=%s)\n',...
        '    tree_elpi = tree_elpi[0]\n\n',...
        '    # Print tree info for debugging\n',...
        '    print(f"Initial tree: {len(tree_elpi[\"NodePositions\"])} nodes, {len(tree_elpi[\"Edges\"][0])} edges")\n',...
        '    \n',...
        '    # Prune the tree\n',...
        '    old_tree = tree_elpi.copy()\n',...
        '    edges = tree_elpi["Edges"][0]\n',...
        '    nodes_positions = tree_elpi["NodePositions"]\n',...
        '    \n',...
        '    g = igraph.Graph()\n',...
        '    g.add_vertices(len(nodes_positions))\n',...
        '    labels = list(range(len(nodes_positions)))\n',...
        '    g.vs["label"] = labels\n',...
        '    g.add_edges(edges)\n',...
        '    \n',...
        '    # Find nodes to remove\n',...
        '    degs = g.degree()\n',...
        '    list_to_remove = []\n',...
        '    for e in g.get_edgelist():\n',...
        '        if degs[e[0]] == 1 and degs[e[1]] > 2:\n',...
        '            list_to_remove.append(e[0])\n',...
        '        if degs[e[1]] == 1 and degs[e[0]] > 2:\n',...
        '            list_to_remove.append(e[1])\n',...
        '    \n',...
        '    list_to_remove = list(set(list_to_remove))\n',...
        '    g.delete_vertices(list_to_remove)\n',...
        '    \n',...
        '    # Create new edge array\n',...
        '    edge_array = np.zeros((len(g.get_edgelist()), 2), dtype=np.int32)\n',...
        '    for i,e in enumerate(g.get_edgelist()):\n',...
        '        edge_array[i,0] = e[0]\n',...
        '        edge_array[i,1] = e[1]\n',...
        '    \n',...
        '    print(f"Removed {len(list_to_remove)} vertices and {len(old_tree[\"Edges\"][0])-len(edge_array)} edges")\n',...
        '    \n',...
        '    tree_elpi["Edges"] = (edge_array, tree_elpi["Edges"][1])\n',...
        '    vs_subset = g.vs["label"]\n',...
        '    tree_elpi["NodePositions"] = nodes_positions[vs_subset,:]\n',...
        '    \n',...
        '    # Print pruned tree info\n',...
        '    print(f"After pruning: {len(tree_elpi[\"NodePositions\"])} nodes, {len(tree_elpi[\"Edges\"][0])} edges")\n',...
        '    \n',...
        '    # Extend leaves\n',...
        '    TargetPG = copy.deepcopy(tree_elpi)\n',...
        '    \n',...
        '    # Create graph for leaf finding\n',...
        '    Net = nx.Graph()\n',...
        '    Net.add_edges_from(tree_elpi["Edges"][0])\n',...
        '    LeafIDs = [n for n,d in Net.degree() if d == 1]\n',...
        '    Nei = [list(Net.neighbors(n)) for n in LeafIDs]\n',...
        '    NodesMat = np.column_stack((LeafIDs, [n[0] for n in Nei]))\n',...
        '    \n',...
        '    # Partition data\n',...
        '    PD = PartitionData(X=X,\n',...
        '                     NodePositions=TargetPG["NodePositions"],\n',...
        '                     MaxBlockSize=10000000,\n',...
        '                     TrimmingRadius=float("inf"),\n',...
        '                     SquaredX=np.sum(X**2, axis=1, keepdims=1))\n',...
        '    \n',...
        '    # Initialize variables for leaf extension\n',...
        '    NodeID = len(TargetPG["NodePositions"])-1\n',...
        '    init = False\n',...
        '    NNPos = None\n',...
        '    NEdgs = None\n',...
        '    UsedNodes = []\n',...
        '    \n',...
        '    # Extend each leaf\n',...
        '    for i in range(len(NodesMat)):\n',...
        '        if np.sum(PD[0] == NodesMat[i,0]) == 0:\n',...
        '            continue\n',...
        '        \n',...
        '        NodeID = NodeID + 1\n',...
        '        tData = X[(PD[0] == NodesMat[i,0]).flatten(),:]\n',...
        '        \n',...
        '        # Project points\n',...
        '        Proj = project_point_onto_edge(X=X[(PD[0] == NodesMat[i,0]).flatten(),:],\n',...
        '                                    NodePositions=TargetPG["NodePositions"],\n',...
        '                                    Edge=NodesMat[i,:])\n',...
        '        \n',...
        '        Dists = PD[1][PD[0] == NodesMat[i,0]]\n',...
        '        Dists[Proj["Projection_Value"] >= 0] = 0\n',...
        '        \n',...
        '        # Calculate weights\n',...
        '        Dist2 = Dists**(2*0.9)\n',...
        '        Wei = Dist2/np.max(Dist2) if np.max(Dist2) > 0 else Dist2\n',...
        '        \n',...
        '        # Calculate new node position\n',...
        '        if len(Wei) > 1:\n',...
        '            NN = np.sum(tData*Wei[:,None], axis=0)/np.sum(Wei)\n',...
        '        else:\n',...
        '            NN = tData\n',...
        '        \n',...
        '        # Store new node\n',...
        '        if not init:\n',...
        '            init = True\n',...
        '            NNPos = NN.copy()\n',...
        '            NEdgs = np.array([[NodesMat[i,0], NodeID]])\n',...
        '            UsedNodes.extend(list(np.where(PD[0].flatten() == NodesMat[i,0])[0]))\n',...
        '        else:\n',...
        '            NNPos = np.vstack((NNPos, NN))\n',...
        '            NEdgs = np.vstack((NEdgs, np.array([[NodesMat[i,0], NodeID]])))\n',...
        '            UsedNodes.extend(list(np.where(PD[0].flatten() == NodesMat[i,0])[0]))\n',...
        '    \n',...
        '    # Update tree with new nodes\n',...
        '    if init:\n',...
        '        TargetPG["NodePositions"] = np.vstack((TargetPG["NodePositions"], NNPos))\n',...
        '        TargetPG["Edges"] = [np.vstack((TargetPG["Edges"][0], NEdgs)),\n',...
        '                           np.append(TargetPG["Edges"][1], np.repeat(np.nan, len(NEdgs)))]\n',...
        '    \n',...
        '    print(f"Final tree: {len(TargetPG[\"NodePositions\"])} nodes, {len(TargetPG[\"Edges\"][0])} edges")\n',...
        '    \n',...
        '    # Save results\n',...
        '    savemat(output_file, {\n',...
        '        "NodePositions": TargetPG["NodePositions"],\n',...
        '        "Edges": TargetPG["Edges"][0]\n',...
        '    })\n',...
        '\n',...
        'if __name__ == "__main__":\n',...
        '    import sys\n',...
        '    compute_tree(sys.argv[1], sys.argv[2])\n'],...
        p.Results.nnodes, p.Results.alpha, p.Results.Mu, p.Results.Lambda,...
        p.Results.FinalEnergy, do_pca_str);
    
    % Save Python script and execute
    script_file = 'temp_compute_elpi.py';
    fid = fopen(script_file, 'w');
    fprintf(fid, '%s', python_script);
    fclose(fid);
    
    % Save input data
    input_file = 'temp_input.mat';
    output_file = 'temp_output.mat';
    save(input_file, 'X');
    
    % Execute Python script
    command = sprintf('/opt/anaconda3/bin/python %s %s %s', script_file, input_file, output_file);
    [status, cmdout] = system(command);
    fprintf('%s\n', cmdout);  % Print Python output for debugging
    
    if status ~= 0
        error('Python script failed: %s', cmdout);
    end
    
    % Load results
    tree_extended = load(output_file);
    
    % Print summary of loaded tree
    fprintf('Loaded tree has %d nodes and %d edges\n', ...
        size(tree_extended.NodePositions, 1), size(tree_extended.Edges, 1));
    
    % Clean up temporary files
    delete(input_file);
    delete(output_file);
    delete(script_file);
end
